<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>袁继伟</title>
  <icon>https://www.gravatar.com/avatar/453e8be73a1bc819c9c425adcdf31bfa</icon>
  <subtitle>Weaving the Web</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiweiyuan.github.io/"/>
  <updated>2020-04-21T02:41:47.755Z</updated>
  <id>https://jiweiyuan.github.io/</id>
  
  <author>
    <name>Jiwei,Yuan</name>
    <email>ji-weiyuan@outlook.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020年前端技术书评</title>
    <link href="https://jiweiyuan.github.io/2020frontendbook/"/>
    <id>https://jiweiyuan.github.io/2020frontendbook/</id>
    <published>2020-04-21T02:36:46.000Z</published>
    <updated>2020-04-21T02:41:47.755Z</updated>
    
    <content type="html"><![CDATA[<p>想系统的掌握一门知识，书籍是比较好的方式。我是比较喜欢看书的，当然，看了书也要多动手实践。记录在2020年研读过的前端技术书籍，日常更新….</p><ol><li><p>刘博文《深入浅出Vue.js》人民邮电出版社 2019.3</p><p>书如其名，深入浅出。现在想找一份前端的工作（15k 以上），面试都会问一些源码的实现，所以读一读这本是还是收获很大的。借助书籍，比直接上手读源码要容易许多。</p></li></ol><ol start="2"><li><p>周俊鹏 《前端技术架构和工程》电子工业出版社 2020.01</p><p>2020年1月出版的书，我四月份买来读的。疫情期间毕竟图书出版行业也会受到一些影响，读这么新鲜的书还是挺开心的。这本书适合刚从事前端的同学读一读，因为内容并不是很深。但如果接触前端不久，倒是可以读一读。但工程化的知识最好在工程的实践中学习，如果没有业务和研究需要，泛读一下即可。我重点看了看第5章前后端分离和第6章性能。</p></li></ol><ol start="3"><li><p>居玉皓《Webpack实践入门、进阶、和调优》机械工业出版社 2019.5</p><p>朋友推荐的，之前工作用webpack, 文档并不是那么友好，一些概念也没有掌握太清楚。这本书，学习梯度划分的很好，循序渐进。另外把一些晦涩的概念也解释的很清楚，难得的一本好书。</p></li></ol><ol start="4"><li></li></ol><p>更新于：2020.04.21</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想系统的掌握一门知识，书籍是比较好的方式。我是比较喜欢看书的，当然，看了书也要多动手实践。记录在2020年研读过的前端技术书籍，日常更新….&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;刘博文《深入浅出Vue.js》人民邮电出版社 2019.3&lt;/p&gt;
&lt;p&gt;书如其名，深入浅出。现在想
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript Questions 刷题笔记</title>
    <link href="https://jiweiyuan.github.io/javascript-questions/"/>
    <id>https://jiweiyuan.github.io/javascript-questions/</id>
    <published>2020-04-21T02:36:46.000Z</published>
    <updated>2021-01-26T12:28:32.160Z</updated>
    
    <content type="html"><![CDATA[<p>这几日用一些零零碎碎的时间看了 <a href="https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md" target="_blank" rel="noopener">JavaScript Questions</a> 这个项目，主要是一些关于JavaScript 语法层面上的一些问题，合计有155道题目，很适合作为面试题库。比如下面的问题我没有做对。</p><h6 id="24-输出是什么？"><a href="#24-输出是什么？" class="headerlink" title="24. 输出是什么？"></a>24. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'c'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 5])</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty('1')</span><br><span class="line">obj.hasOwnProperty(1)</span><br><span class="line"><span class="keyword">set</span>.has('1')</span><br><span class="line"><span class="keyword">set</span>.has(1)</span><br></pre></td></tr></table></figure><ul><li>A: <code>false</code> <code>true</code> <code>false</code> <code>true</code></li><li>B: <code>false</code> <code>true</code> <code>true</code> <code>true</code></li><li>C: <code>true</code> <code>true</code> <code>false</code> <code>true</code></li><li>D: <code>true</code> <code>true</code> <code>true</code> <code>true</code></li></ul><details><summary><b>答案</b></summary><br><p><br><br>#### 答案: C<br><br>所有对象的键（不包括 Symbol）在底层都是字符串，即使你自己没有将其作为字符串输入。这就是为什么 <code>obj.hasOwnProperty(&#39;1&#39;)</code> 也返回 <code>true</code>。<br><br>对于集合，它不是这样工作的。在我们的集合中没有 <code>&#39;1&#39;</code>：<code>set.has(&#39;1&#39;)</code> 返回 <code>false</code>。它有数字类型为 <code>1</code>，<code>set.has(1)</code> 返回 <code>true</code>。<br><br></p><br></details><hr><h6 id="29-输出是什么？"><a href="#29-输出是什么？" class="headerlink" title="29. 输出是什么？"></a>29. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">key</span>: <span class="string">'b'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> c = &#123; <span class="attr">key</span>: <span class="string">'c'</span> &#125;</span><br><span class="line"></span><br><span class="line">a[b] = <span class="number">123</span></span><br><span class="line">a[c] = <span class="number">456</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[b])</span><br></pre></td></tr></table></figure><ul><li>A: <code>123</code></li><li>B: <code>456</code></li><li>C: <code>undefined</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><br><p><br><br>#### 答案: B<br><br>对象的键被自动转换为字符串。我们试图将一个对象 <code>b</code> 设置为对象 <code>a</code> 的键，且相应的值为 <code>123</code>。<br><br>然而，当字符串化一个对象时，它会变成 <code>&quot;[object Object]&quot;</code>。因此这里说的是，<code>a[&quot;[object Object]&quot;] = 123</code>。然后，我们再一次做了同样的事情，<code>c</code> 是另外一个对象，这里也有隐式字符串化，于是，<code>a[&quot;[object Object]&quot;] = 456</code>。<br><br>然后，我们打印 <code>a[b]</code>，也就是 <code>a[&quot;[object Object]&quot;]</code>。之前刚设置为 <code>456</code>，因此返回的是 <code>456</code>。<br><br></p><br></details><hr><h6 id="37-输出是什么？"><a href="#37-输出是什么？" class="headerlink" title="37. 输出是什么？"></a>37. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">numbers[<span class="number">10</span>] = <span class="number">11</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers)</span><br></pre></td></tr></table></figure><ul><li>A: <code>[1, 2, 3, 7 x null, 11]</code></li><li>B: <code>[1, 2, 3, 11]</code></li><li>C: <code>[1, 2, 3, 7 x empty, 11]</code></li><li>D: <code>SyntaxError</code></li></ul><details><summary><b>答案</b></summary><br><p><br><br>#### 答案: C<br><br>当你为数组设置超过数组长度的值的时候， JavaScript 会创建名为 “empty slots” 的东西。它们的值实际上是 <code>undefined</code>。你会看到以下场景：<br><br><code>[1, 2, 3, 7 x empty, 11]</code><br><br>这取决于你的运行环境（每个浏览器，以及 node 环境，都有可能不同）<br><br></p><br></details><hr><h6 id="71-如何能打印出console-log语句后注释掉的值？"><a href="#71-如何能打印出console-log语句后注释掉的值？" class="headerlink" title="71. 如何能打印出console.log语句后注释掉的值？"></a>71. 如何能打印出<code>console.log</code>语句后注释掉的值？</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">startGame</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> 答案 = <span class="keyword">yield</span> <span class="string">"Do you love JavaScript?"</span>;</span><br><span class="line">  <span class="keyword">if</span> (答案 !== <span class="string">"Yes"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Oh wow... Guess we're gone here"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"JavaScript loves you back ❤️"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> game = startGame();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="comment">/* 1 */</span>); <span class="comment">// Do you love JavaScript?</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="comment">/* 2 */</span>); <span class="comment">// JavaScript loves you back ❤️</span></span><br></pre></td></tr></table></figure><ul><li>A: <code>game.next(&quot;Yes&quot;).value</code> and <code>game.next().value</code></li><li>B: <code>game.next.value(&quot;Yes&quot;)</code> and <code>game.next.value()</code></li><li>C: <code>game.next().value</code> and <code>game.next(&quot;Yes&quot;).value</code></li><li>D: <code>game.next.value()</code> and <code>game.next.value(&quot;Yes&quot;)</code></li></ul><details><summary><b>答案</b></summary><br><p><br><br>#### 答案: C<br><br><code>generator</code>函数在遇到<code>yield</code>关键字时会“暂停”其执行。 首先，我们需要让函数产生字符串<code>Do you love JavaScript?</code>，这可以通过调用<code>game.next().value</code>来完成。上述函数的第一行就有一个<code>yield</code>关键字，那么运行立即停止了，<code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>, 这意味着此时变量 <code>答案</code> 为<code>undefined</code><br><br><code>next</code>方法可以带一个参数，该参数会被当作上一个 <code>yield</code> 表达式的返回值。当我们调用<code>game.next(&quot;Yes&quot;).value</code>时，先前的 <code>yield</code> 的返回值将被替换为传递给<code>next()</code>函数的参数<code>&quot;Yes&quot;</code>。此时变量 <code>答案</code> 被赋值为 <code>&quot;Yes&quot;</code>，<code>if</code>语句返回<code>false</code>，所以<code>JavaScript loves you back ❤️</code>被打印。<br><br></p><br></details><hr><h6 id="73-输出什么"><a href="#73-输出什么" class="headerlink" title="73. 输出什么?"></a>73. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">"I made it!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = getData();</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;I made it!&quot;</code></li><li>B: <code>Promise {&lt;resolved&gt;: &quot;I made it!&quot;}</code></li><li>C: <code>Promise {&lt;pending&gt;}</code></li><li>D: <code>undefined</code></li></ul><details><summary><b>答案</b></summary><br><p><br><br>#### 答案: C<br><br>异步函数始终返回一个promise。<code>await</code>仍然需要等待promise的解决：当我们调用<code>getData()</code>并将其赋值给<code>data</code>，此时<code>data</code>为<code>getData</code>方法返回的一个挂起的promise，该promise并没有解决。<br><br>如果我们想要访问已解决的值<code>&quot;I made it!&quot;</code>，可以在<code>data</code>上使用<code>.then()</code>方法：<br><br><code>data.then(res =&gt; console.log(res))</code><br><br>这样将打印 <code>&quot;I made it!&quot;</code><br><br></p><br></details><hr><h6 id="74-输出什么"><a href="#74-输出什么" class="headerlink" title="74. 输出什么?"></a>74. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addToList</span>(<span class="params">item, list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> list.push(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = addToList(<span class="string">"apple"</span>, [<span class="string">"banana"</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><ul><li>A: <code>[&#39;apple&#39;, &#39;banana&#39;]</code></li><li>B: <code>2</code></li><li>C: <code>true</code></li><li>D: <code>undefined</code></li></ul><details><summary><b>答案</b></summary><br><p><br><br>#### 答案: B<br><br><code>push()</code>方法返回新数组的长度。一开始，数组包含一个元素（字符串<code>&quot;banana&quot;</code>），长度为1。 在数组中添加字符串<code>&quot;apple&quot;</code>后，长度变为2，并将从<code>addToList</code>函数返回。<br><br><code>push</code>方法修改原始数组，如果你想从函数返回数组而不是数组长度，那么应该在push <code>item</code>之后返回<code>list</code>。<br><br></p><br></details><hr><h6 id="83-输出什么"><a href="#83-输出什么" class="headerlink" title="83. 输出什么?"></a>83. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Lydia"</span>,</span><br><span class="line">  age: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> city = person.city</span><br><span class="line">city = <span class="string">"Amsterdam"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br></pre></td></tr></table></figure><ul><li>A: <code>{ name: &quot;Lydia&quot;, age: 21 }</code></li><li>B: <code>{ name: &quot;Lydia&quot;, age: 21, city: &quot;Amsterdam&quot; }</code></li><li>C: <code>{ name: &quot;Lydia&quot;, age: 21, city: undefined }</code></li><li>D: <code>&quot;Amsterdam&quot;</code></li></ul><details><summary><b>答案</b></summary><br><p><br><br>#### 答案: A<br><br>我们将变量<code>city</code>设置为等于<code>person</code>对象上名为<code>city</code>的属性的值。 这个对象上没有名为<code>city</code>的属性，因此变量<code>city</code>的值为<code>undefined</code>。<br><br>请注意，我们没有引用<code>person</code>对象本身，只是将变量<code>city</code>设置为等于<code>person</code>对象上<code>city</code>属性的当前值。<br><br>然后，我们将<code>city</code>设置为等于字符串<code>“Amsterdam”</code>。 这不会更改person对象：没有对该对象的引用。<br><br>因此打印<code>person</code>对象时，会返回未修改的对象。<br><br></p><br></details><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几日用一些零零碎碎的时间看了 &lt;a href=&quot;https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>翻译:Javascript 的构造</title>
    <link href="https://jiweiyuan.github.io/justjavascript/"/>
    <id>https://jiweiyuan.github.io/justjavascript/</id>
    <published>2020-03-29T10:06:58.000Z</published>
    <updated>2020-03-29T10:13:44.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="译序"><a href="#译序" class="headerlink" title="译序"></a>译序</h2><p>物理学家在研究时强调逻辑和数学，也会强调物理直觉和物理图像带来的启发。一个经典例子：物理世界当然不存在电场图和电磁图，但我们将其理解电磁世界重要的工具。一张好图胜过千言万语。编程当然是一个强调逻辑的智力活动，但与物理学类似，我们同样可以运用直觉和图像思维，来增进我们对于代码的理解。在 <strong><a href="https://justjavascript.com/" target="_blank" rel="noopener">Just JavaScript</a></strong> 中，作者 Dan Abramov 给我们一个很好的示范，展示了他所构建的 Javascript 心智模型，呈现他建构的程序图像和代码直觉。本文是他对于Just Javascript 概述介绍说明。将 <a href="https://overreacted.io/what-is-javascript-made-of/" target="_blank" rel="noopener">原文</a>翻译如下，译者水平有限，难免多疏漏，望多多批评指正。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在我早年使用 Javascript 的时候，感觉自己像个骗子。尽管能用框架搭建网站，还是少了一些东西。因为基础不牢，我害怕Javascript的工作面试。</p><p>几年后，我构建出一个 Javascript <strong>心智模型</strong>，它给我信心。这里，我分享这个模型的<strong>超级压缩</strong>版。像词汇表一样，每个话题都有几句话。</p><p>读这篇文章时，心里试着对每个话题的熟悉程度打个分。如果有些内容你未曾了解过，我不会介意，文章结尾有些东西或许能帮到你！</p><p><strong>值（Value）</strong>: 值的概念是有点抽象的，它是一个实体。值对于 Javascript 来说，就像数学中的数，集合中的点。当你的程序运行时，这是一个充满值的世界。像 <code>1</code> 、 <code>2</code> 和 <code>420</code> 这样的数是值，还有， 像 <code>&quot;Cows go moo&quot;</code>  这样的句子也是值。但并非所有的东西都是值， 一个数是值，但 <code>if</code> 语句不是，我们讨论下面一些不同类型的值：</p><ul><li><strong>值类型（Type of Value)</strong>：值有不同的数据类型，比如 像<code>420</code> 这样的 <strong>numbers</strong>  数据类型，像 <code>&quot;Cows go moo&quot;</code> 这样的 <strong>strings</strong> 数据类型，还有 <strong>objects</strong> … 等等一些其他的数据类型。你可以在一个值前面使用 <code>typeof</code> 来获取其类型。比如 <code>console.log(typeof 2)</code> 会输出 <code>number</code>。</li><li><strong>原始值（Primitive Values)</strong>: 一些值类型是原始的，有 numbers 、strings …… 原始值的一个奇特之处在于，你不能创造更多的原始值，也不能以任何方式改变原始值。例如，每次编写 <code>2</code> 时，都会得到相同的 <code>2</code> 值。你不能在你的程序中创建另一个 <code>2</code> 值，或者使 <code>2</code> 值变成 <code>3</code>。这也适用于字符串。(译者注：just javascript 模型x详细描述了这种值的”图像直觉”。每一个值都是独一无二的实体。<code>1</code> 和 <code>1</code> 是同一个实体， <code>1</code> 与 <code>2</code> 是不同的实体， <code>{name: &#39;javascipt&#39; }</code> 与  <code>{name: &#39;javascipt&#39; }</code> 是不同的实体。这一点在 详细阅读 just javascript， 读者可以有更深入的体会。)</li><li><strong><code>null</code> 与 <code>undefined</code></strong>: 它们是两类特殊的值。之所以特别，是因为有很多事情你不能用它们来做，他们常常会导致错误。通常， <code>null</code> 代表故意缺失的值，而 <code>undefined</code> 代表无意间缺失的值。然而，何时使用他们都由程序员来决定。他们之所以存在，因为有时程序操作失败比带着一个缺失的值运行好。</li></ul><p><strong>相等 (Equality)</strong>: 和值一样，相等也是 Javascript 中的一个基础概念。我们说两个值是相等的当他们…… 事实上，我不会这么讲。如果两个值是相等的，这意味着他们是相同的值。他们并非两个不同值，而是同一个值。例如，<code>&quot;Cows go moo&quot; === &quot;Cows go moo&quot;</code> 或者 <code>2 === 2</code> 是因为2就是2 。 注意，我们在 Javascript 中使用三种等号来表示 相等性。</p><ul><li><strong>严格相等（Strict Equality 即 ===）</strong>：如上所述，同一个值</li><li><strong>引用相等（Referential Equality 即 = ）</strong>：如上所述，同一个值（译者注即引用数据类型的空间地址相同）</li><li><strong>不严格相等（Loose Equality 即 =  )</strong>:  哦，这个有些不一样。当我们使用两个等号 <code>==</code> 时，代表不严格相等。有过有些看起来相似的不同值（比如 <code>2</code> 和 <code>&quot;2&quot;</code> ), 可以被视为不严格相等。 它早期是为了方便添加到 JavaScript 中的，但此后一直引起无休止的混乱。 这个概念不是基础，而是常见的错误源头。 你可以没事的时候研究它如何工作，但是许多人都在尝试避免它。</li></ul><p><strong>字面量(Literal)</strong>: 字面量是你通过在程序中字面地写下它来引用一个值。例如，<code>2</code> 是数字字面量， <code>&quot;Banana&quot;</code> 是字符串字面量。</p><p><strong>变量（Variable）</strong>:  一个变量能让你通过使用一个名字引用一些值。例如，<code>let message = &quot;Cows go moo&quot;</code> 。现在你可以写 <code>message</code> 而不必每次在代码中重复同样的句子。稍后你也可以更改 <code>message</code> 指向另一个值， 像 <code>message = &quot;I am the walrus&quot;</code> 。 注意，这不改变值本身，而是改变 <code>message</code> 的指向。就像一条连线一样，之前指向 <code>&quot;Cows go moo&quot;</code> , 现在指向 <code>&quot;I am the walrus&quot;</code> 。</p><ul><li><strong>作用域(Scope作用域)</strong>: 如果在你整个程序中只有一个 <code>message</code> 变量，这将会是一件十分糟糕的事情。相反，当你定义一个变量时，它只在你程序的局部可用，这一部分即为”作用域”。关于作用域如何工作有 很多规则，但一般来讲，你可用通过寻找定义变量位置附近的 <code>{ }</code>,  括号为其作用域。</li><li><strong>赋值(Assignment)</strong> : 当我们写 <code>message = &quot;I am the walrus&quot;</code> , 我们改变 <code>message</code> 变量来指向 <code>&quot;I am the walrus&quot;</code>。 这被叫做赋值，也叫做定义变量。</li><li><strong>变量声明 (<code>let</code> vs <code>const</code> vs <code>var</code>)</strong>: 通常你想使用 <code>let</code> 。如果你想禁止对该变量赋值，你可以使用 <code>const</code> 。(当只有一次赋值时，有些死板的同事会强迫你使用 <code>const</code>。) 尽可能避免使用 <code>var</code> , 因为它的作用域规则令人困惑。</li></ul><p><strong>对象(Object)</strong>: 对象是 JavaScript 中的一种特殊值。 对象最酷的地方在于，它们可以连接到其他值。 例如，<code>{flavor: &quot;vanilla&quot;}</code> 对象具有指向 <code>&quot; vanilla&quot;</code> 值的 <code>flavor</code> 属性。 将一个对象视为“您自己的”值，其中包含一些“连线”。</p><ul><li><strong>属性(Property)</strong>: 属性类似于粘在对象上并指向某个值的“线”。 这可能会让您想起变量: 它有一个名称(如 <code>flavor</code>)并指向一个值(如 <code>&quot;vanilla&quot;</code>)。 但与变量不同的是，属性“存在”于对象本身，而不是代码(作用域)中的某个位置。 一个属性被认为是对象的一部分—但它指向的值不是。</li><li><strong>对象字面量(Object Literal)</strong>: 对象字面量是一种通过在程序中直接写入来创建对象值的方法，比如 <code>{}</code>或 <code>{ flavor: “&quot;anilla&quot;}</code>。 在 <code>{}</code> 中，我们可以有多个属性: 值对，用逗号分隔。 这让我们可以设置对象中属性“连线”指向的位置。</li><li><strong>对象身份(Object Identity)</strong>: 我们前面提到 <code>2</code> 等于 <code>2</code>(换句话说，<code>2===2</code>) ，因为每当我们写2时，我们“召唤”同样的值。 但是当我们写<code>{ }</code>的时候，我们总会得到一个不同的值！ 所以<code>{ }</code>不等于另一个 <code>{ }</code>。 在控制台中尝试:<code>{ }==={ }</code> (结果为 false)。 当计算机在我们的代码中遇到2时，它总是给我们相同的2值。 但是，对象字面量是不同的: 当计算机遇到<code>{ }</code>时，它创建一个新对象，该对象始终是一个新的值。 那么什么是对象身份呢？ 这是另一个表示相等或者值相同的术语。 当我们说“ <code>a</code> 和  <code>b</code>  具有相同的身份”时，我们的意思是 <code>a</code>  和 <code>b</code> 指向相同的值( <code>a === b</code> )。 当我们说“ <code>a</code> 和 <code>b</code> 有不同的身份”时，我们的意思是 <code>a</code>  和 <code>b</code> 指向不同的值 ( <code>a !== b</code> ).</li><li><strong>点表示法(Dot Notation）</strong>: 当你想从一个对象读取一个属性或者给它赋值时，你可以使用点(<code>.</code>) 符号。 例如，如果一个变量 <code>iceCream</code> 指向一个属性 <code>flavor</code> 指向 <code>&quot;chocolate&quot;</code> 的对象，那么写 <code>iceCream.flavor</code>就会代表 <code>&quot;chocolate&quot;</code>.</li><li><strong>括号表示法(Bracket Notation)</strong>: 有时候你不能预先知道你想读取的属性的名称。 例如，有时候你想读取 <code>iceCream.flavor</code> , 有时候你想读取 <code>iceCream.taste</code> 。 当属性的名称本身是一个变量时，使用括号(<code>[ ]</code>)符号可以读取该属性。 例如，如果 <code>let ourProperty=&quot;flavor&quot;</code>。 然后，<code>iceCream[ourProperty ]</code> 会给我们 <code>&quot;chocolate&quot;</code>。 令人吃惊的是，我们也可以在创建对象时使用它:<code>{[ ourProperty ] : &quot;vanilla&quot;}</code></li><li><strong>改变(Mutation)</strong>: 当有人改变一个对象的属性来指向一个不同的值，我们说这个对象就发生了改变。 例如，如果我们声明<code>let  iceCream  = { flavor: &quot; vanilla&quot;}</code> ，我们可以稍后用 <code>iceCream.flavor=&quot;chocolate&quot;</code>对其进行改变。 注意，即使我们使用 <code>const</code> 来声明 <code>iceCream</code> ，我们仍然可以对 <code>iceCream.flavor</code> 进行改变。 这是因为 <code>const</code>只会阻止对 <code>iceCream</code> 变量本身赋值，但是我们对对象属性 (<code>flavor</code>) 的指向进行了改变。 有些人发誓完全不使用 const，因为他们觉得这太具有误导性</li><li><strong>数组(Array)</strong>: 数组是一个对象，表示一系列的东西。 当您编写一个数组字面值, 像<code>[&quot; banana&quot;, &quot;chocolate&quot;, &quot;vanilla&quot;]</code>时，实际上您创建了一个对象。其属性<code>0</code>指向<code>&quot;banana&quot;</code>字符串值，属性 <code>1</code> 指向 <code>&quot;chocolate&quot;</code>值，属性为<code>2</code>指向 <code>&quot;vanilla&quot;</code> 值。 如果写 <code>{0: ..., 1: ..., 2: ...}</code>会很烦人，这就是数组有用的原因。 还有一些内置的方法来操作数组，如 <code>map</code>、<code>filter</code> 和 <code>reduce</code>。 如果 reduce 看起来令人困惑，不要绝望——它让每个人都感到困惑。</li><li><strong>原型(Prototype)</strong>: 如果我们读取一个不存在的属性会发生什么？ 例如，<code>iceCream.taste</code> (但我们的属性为 <code>flavor</code> )。 简单的回答是：我们将得到特殊的 <code>undefined</code> 值。 更细致的答案是：JavaScript 中的大多数对象都有一个“原型”。 您可以将原型看作是每个对象上的“隐藏”属性，它决定了“下一步要查看哪里”。 因此，如果在 <code>iceCream</code>上没有 <code>taste</code>属性，JavaScript 将在其原型上寻找 <code>taste</code> 属性，然后在该对象原型的原型上寻找 <code>taste</code> 属性…… 只有当它到达这个“原型链”的末端而没有找到 <code>.taste</code> , 才会给出 <code>undefined</code> 。  你很少直接与这个机制打交道，但它解释了为什么我们的 <code>iceCream</code> 对象有一个我们从未定义过的 <code>toString</code> 方法 —— 它来自原型。</li></ul><p><strong>函数(Function)</strong>: 函数是一个特殊的值，它只有一个用途: 它表示程序中的一些代码。 如果您不想多次编写相同的代码，那么函数很方便。像 <code>sayHi()</code> 这样 “调用”一个函数，是告诉计算机运行其中的代码，然后返回到它在程序中的位置。 在 JavaScript 中定义函数的方法有很多种，他们有一些细微的差别。</p><ul><li><strong>参数(Argument or Parameters)</strong>: 参数允许您从调用它的位置向函数传递一些信息，比如 <code>sayHi (&quot;Amelie&quot;)</code>。 在函数内部，它们的作用类似于变量。 它们被称为参数(Argument or Parameters) ，这取决于您正在做什么事(函数定义或函数调用)。 然而，这种术语上的区别是迂腐的，在实践中这两个术语可以互换使用。（译者注：英文中Argument 专用于 Actual Argument（实际参数，实参），Parameter 专用于 Formal Parameter（形式参数，形参），中文一般都将其翻译为参数）</li><li><strong>函数表达式(Function Expression)</strong>: 之前，我们将变量设置为一个字符串值，比如 <code>let message = &quot;I am the walrus&quot;</code> 。 事实上，我们也可以为函数设置一个变量，比如 <code>let  sayHi = function(){ }</code>。 <code>=</code> 后的东西叫做函数表达式。 它为我们提供了一个特殊的值(一个函数)来表示我们的代码片段，如果我们愿意，我们可以稍后调用它。</li><li><strong>函数声明(Function Delaration)</strong>: 写一个 <code>let sayHi = function() { }</code>是很累的，所以我们可以用一个更短的形式来代替: <code>function sayHi(){ }</code> ,这被称为函数声明。 我们没有在左边指定变量名，而是将其放在 function 关键字之后。 这两种风格大多是可以互换的。</li><li><strong>函数提升（Function Hoisting)</strong>: 通常，您只能 let 或 const 声明后使用一个变量。 函数之间可能需要相互调用，这可能会令人讨厌，因为很难跟踪哪个函数使用了哪个函数，以及哪个函数需要首先定义。 作为一种方便，当（且仅） 使用函数声明语法，它们的定义顺序并不重要，因为它们会“提升”。 这是一种奇特的说法，从概念上讲，它们都自动移动到作用域的顶部。 当你调用的时候，他们都已经定义好了。</li><li><strong><code>this</code></strong> :  大概是Javascript 最容易迷惑的概念。 this 对一个函数来说是一个特别的参数。你不能把它传递给你自己的函数，相反，Javascript  会根据如何调用函数自己传递它。就像当你使用 <code>.</code> 表示法 ，像 <code>iceCream.eat()</code>  ，将会从<code>.</code> 之前得到一个特殊的 <code>this</code> 值（在我们的例子中，是 <code>iceCream</code> ) 。函数内部的 <code>this</code> 值取决于函数如何被调用，而不是如何被定义。像 <code>.bind</code> 、<code>.call</code> 、 <code>.apply</code> 这些辅助可以让你更方便的控制 <code>this</code> 。</li><li><strong>箭头函数(Arrow Functions)</strong>: 箭头函数类似于函数表达式。 你这样声明它们: <code>let sayHi = () =&gt; { }</code>。 它们很简洁，经常用于一行程序。 箭头函数比常规函数有更多的局限性——例如，它们没有 <code>this</code> 概念。 在箭头函数中编写 <code>this</code> 时，它使用上层最接近的“常规”函数中的 <code>this</code> 。 这与使用仅存在于上面的函数中的参数或变量类似。 实际上，这意味着人们使用箭头函数时，他们希望内部与外部使用同一个 <code>this</code>。</li><li><strong>函数绑定(Function Binding)</strong>: 通常，给函数 <code>f</code> 绑定到特定的 <code>this</code> 值和 arguments 意味着创建一个新函数，该函数使用那些预定义的值调用 <code>f</code>。 Javascript 有一个内置的辅助<code>.bind</code> 来完成它,但你也可以手动实现。 绑定是使嵌套函数具有与外部函数相同的 <code>this</code> 的一种流行方法。 但是这个目的现在一般由箭头函数实现，所以绑定并不经常使用</li><li><strong>调用栈(Call Stack)</strong>: 调用一个函数就像进入一个房间。 每次我们调用一个函数，函数内部的变量都会被重新初始化。 因此，每个函数调用就像用它的代码构造一个新的“房间” ，然后进入它。 我们函数的变量在那个房间里“存活”。 当我们从函数返回时，“房间”和它的所有变量一起消失。 你可以把这些房间想象成一个垂直的房间栈——一个调用栈。 当我们退出一个函数时，我们返回到调用栈上它下面的函数。</li><li><strong>递归(Recursion)</strong>: 递归意味着函数从自身内部调用自身。 当您想要重复刚才在函数中所做的事情时，这是非常有用的，但是他们参数不同。 例如，如果您正在编写一个搜索引擎来爬取网页，那么 <code>collectLinks (url)</code> 函数可能首先从一个页面收集链接，然后为每个链接调用自身，直到它访问所有页面。 递归的缺陷在于，很容易编写永远不会结束的代码，因为函数会永远调用自己。 如果发生这种情况，JavaScript 将通过一个名为“堆栈溢出”的错误来停止它。 之所以这样称呼，是因为这意味着我们在调用栈中堆积了太多的函数调用，而且函数调用已经超出了调用栈的范围.</li><li><strong>高阶函数(Higher-Order Function)</strong>: 高阶函数函数是一个处理其他函数的函数，通过将其他函数作为参数或返回它们。 这在一开始可能看起来很奇怪，但是我们应该记住函数是值，这样我们就可以像传递数字、字符串或对象一样传递它们。 这种风格可能会被过度使用，但是它在适度的情况下非常有用。<ul><li><strong>回调(Callback)</strong>: 回调不是一个真正的 JavaScript 术语。 它更像是一种模式。 当你将一个函数作为参数传递给另一个函数，期望它稍后调用你的函数。 你在等一个“回调”。 例如，<code>setTimeout</code> 接受一个回调函数，时间到了h回头调用它。 但是回调函数没有什么特别的。 它们是常规函数，当我们说“回调”时，我们只谈论我们的期望（希望回头执行）。</li></ul></li><li><strong>闭包（Closure)</strong>: 通常，当执行完退出一个函数时，函数的所有变量都会“消失”。 这是因为没有东西再需要它们了。 但是如果在函数中声明一个函数呢？ 仍然可以稍后调用这个内部函数，并读取外部函数的变量。 在实践中，这是非常有用的！ 但是为了实现这一点，外部函数的变量需要在某个地方“逗留”。 因此，在这种情况下，JavaScript 会注意“保持变量存在” ，而不是像通常那样“忘记”它们。 这就是所谓的“闭包”。 虽然闭包经常被认为是一个被误解的 JavaScript 方面，但是您可能一天使用它们很多次却没有意识到这一点。</li></ul><p>JavasScript 正是由这些概念组成。对于 JavaScript 的知识，我曾一度感觉十分不安，直到我可以构建一个正确的心理模型。我乐意帮助下一代的开发者尽快弥补这一差距。</p><p>如果你想跟我进一步深入到上面这些话题，我有些东西给你。<strong><a href="https://justjavascript.com/" target="_blank" rel="noopener">Just JavaScript</a> 是我关于JavaScript工作原理的精炼思维模型，且还有奇人 <a href="https://illustrated.dev/" target="_blank" rel="noopener">Maggie Appleton</a> 所作的一些插画展示。</strong> </p><p><strong><a href="https://justjavascript.com/" target="_blank" rel="noopener">Just Javascript</a></strong> 还处于早期阶段，目前只是一系列的电子邮件，也没有任何修饰和编辑。 如果你有兴趣，可以通过 <a href="https://justjavascript.com/" target="_blank" rel="noopener">订阅</a> 邮件接收这些草稿。对你的反馈，我会十分感激。再次感谢！</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>Dan Abramov,  就职于Facebook(London)。关于作者经历可以看下面这篇文章：<a href="https://overreacted.io/zh-hans/my-decade-in-review/" target="_blank" rel="noopener">我的十年回顾</a> 。 另外我阅读学习 <strong><a href="https://justjavascript.com/" target="_blank" rel="noopener">Just JavaScript</a></strong> 过程中收获颇多，因为Just Javascript 基本上是周更，所以建立一个 Just JavaScript 微信交流群，感兴趣的朋友可以加我微信（ji-weiyuan)，可以一起探讨研究，追更。</p><h2 id="译者"><a href="#译者" class="headerlink" title="译者"></a>译者</h2><p><a href="https://yuanjiwei.com" target="_blank" rel="noopener">袁继伟</a>:  (微信：<code>ji-weiyuan</code>  微信公众号：<code>袁继伟</code> )</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;译序&quot;&gt;&lt;a href=&quot;#译序&quot; class=&quot;headerlink&quot; title=&quot;译序&quot;&gt;&lt;/a&gt;译序&lt;/h2&gt;&lt;p&gt;物理学家在研究时强调逻辑和数学，也会强调物理直觉和物理图像带来的启发。一个经典例子：物理世界当然不存在电场图和电磁图，但我们将其理解电磁世界
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的博客</title>
    <link href="https://jiweiyuan.github.io/myblog/"/>
    <id>https://jiweiyuan.github.io/myblog/</id>
    <published>2020-03-11T05:41:37.000Z</published>
    <updated>2020-03-15T02:12:16.924Z</updated>
    
    <content type="html"><![CDATA[<p>在大二的时候，内心渴望有一个地方与世界沟通表达，接触并尝试了自建博客。但没有实质性的输出，在工具与形式的尝试中消耗着时间，也消耗着表达的热情。</p><p>因为在互联网中看到 <a href="https://bloghub.fun/" target="_blank" rel="noopener">https://bloghub.fun/</a> , 看到许多人坚守着文字，分享文字的热情便重新燃起。在载体上做了一些思考（愈简单愈好）。博客主要以 Markdown 形式放到 Github 上，部分会推送到微信公众号(袁继伟)，部分更新到 <a href="http://www.yuanjiwei.com" target="_blank" rel="noopener">www.yuanjiwei.com</a>  。</p><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>现阶段的写作平台。</p><ol><li>GitHub：<a href="https://github.com/jiweiyuan/blog" target="_blank" rel="noopener">https://github.com/jiweiyuan/blog</a></li><li>微信公众号:  袁继伟</li></ol><p>虽然建立了一个网站，<a href="http://www.yuanjiwei.com" target="_blank" rel="noopener">www.yuanjiwei.com</a> 。基于 GitHub Pages + Hexo 的方案，采用的是 <code>hexo-theme-yinwang</code> 的主题（模仿 <a href="http://www.yinwang.org" target="_blank" rel="noopener">www.yinwang.org</a> 网站的风格），觉得十分简洁，便拿来用了。因为懒得配置图床，一般只将纯文字的非技术内容放到博客上。工具链太复杂，会损害表达的热情。毕竟，这些文字是面向自我的。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>写作有面向自己的写作，也有面向他人的写作。自己成长于文字时代，生命中重要的见识通常源于文字。虽曾流连流媒体几多光年， “万花从中过，片叶不沾身” ，流媒体很好看，却很难留在心里。相比流媒体，文字有信息密度更大，创作也更加便易。热爱文字，便勤耕读于文字吧！自勉之。</p><p>—— 初记于 2020.03.13</p><p>—— 增删于 2020.03.15</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在大二的时候，内心渴望有一个地方与世界沟通表达，接触并尝试了自建博客。但没有实质性的输出，在工具与形式的尝试中消耗着时间，也消耗着表达的热情。&lt;/p&gt;
&lt;p&gt;因为在互联网中看到 &lt;a href=&quot;https://bloghub.fun/&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>技术博客与交流群组</title>
    <link href="https://jiweiyuan.github.io/techblog/"/>
    <id>https://jiweiyuan.github.io/techblog/</id>
    <published>2020-03-11T05:41:37.000Z</published>
    <updated>2020-03-23T12:43:26.756Z</updated>
    
    <content type="html"><![CDATA[<p>以输出为目的的输入是最有效率的。目前技术内容主要更新在GitHub上（一些文章同步更新到掘金）。</p><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>我的掘金主页: <a href="https://juejin.im/user/5e41f19f6fb9a07cab3a8ae5" target="_blank" rel="noopener">袁继伟</a></p><h3 id="群组"><a href="#群组" class="headerlink" title="群组"></a>群组</h3><p>我组织了一些技术交流小组，有兴趣的话，欢迎添加我的微信（ji-weiyuan) 告诉我你想加入的小组（若方便，简单自我介绍一下）。</p><ol><li>Just Javascript 读书小组 (开始于2020年3月)</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>事物是不断发展和调整变化的。</p><p>—— 初记于 2020.03.23</p><p>—— 增删于 2020.03.23</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以输出为目的的输入是最有效率的。目前技术内容主要更新在GitHub上（一些文章同步更新到掘金）。&lt;/p&gt;
&lt;h3 id=&quot;博客&quot;&gt;&lt;a href=&quot;#博客&quot; class=&quot;headerlink&quot; title=&quot;博客&quot;&gt;&lt;/a&gt;博客&lt;/h3&gt;&lt;p&gt;我的掘金主页: &lt;a hre
      
    
    </summary>
    
    
  </entry>
  
</feed>
